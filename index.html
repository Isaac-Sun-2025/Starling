<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=375, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>FlashWatch</title>
<script src="https://cdn.tailwindcss.com/3.4.16"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.6.0/remixicon.min.css" rel="stylesheet">
<script>
tailwind.config = {
theme: {
extend: {
colors: {
primary: '#007AFF',
secondary: '#E5E7EB'
},
borderRadius: {
'none': '0px',
'sm': '4px',
DEFAULT: '8px',
'md': '12px',
'lg': '16px',
'xl': '20px',
'2xl': '24px',
'3xl': '32px',
'full': '9999px',
'button': '8px'
}
}
}
}
</script>
<style>
:where([class^="ri-"])::before { content: "\f3c2"; }
@media (min-width: 768px) {
.desktop-view { display: block; }
.watch-view { display: none; }
}
@media (max-width: 767px) {
.desktop-view { display: none; }
.watch-view { display: block; }
}
.flashcard {
transition: transform 0.6s;
transform-style: preserve-3d;
}
.flashcard.flipped {
transform: rotateY(180deg);
}
.flashcard-front, .flashcard-back {
backface-visibility: hidden;
position: absolute;
width: 100%;
height: 100%;
}
.flashcard-back {
transform: rotateY(180deg);
}
body {
width: 375px;
margin: 0 auto;
overflow-x: hidden;
}
#edit-modal {
transition: opacity 0.3s ease;
}
#edit-modal.hidden {
opacity: 0;
pointer-events: none;
}
@keyframes pulse {
0% { opacity: 1; }
50% { opacity: 0.5; }
100% { opacity: 1; }
}
.sync-indicator {
animation: pulse 2s infinite;
}
.sync-notification {
animation: slideIn 0.3s forwards;
}
@keyframes slideIn {
from { transform: translate(-50%, 100%); opacity: 0; }
to { transform: translate(-50%, 0); opacity: 1; }
}
</style>
</head>
<body class="bg-black text-white min-h-screen w-[375px] mx-auto overflow-x-hidden">
<div class="desktop-view p-4">
<header class="flex justify-between items-center mb-6">
<h1 class="text-2xl font-['Pacifico']">FlashWatch</h1>
<div class="sync-status text-sm text-primary flex items-center">
  <span>Last synced: Just now</span>
  <i class="ri-wifi-line ml-1"></i>
</div>
</header>
<div class="grid grid-cols-2 gap-4">
<div class="deck-list space-y-4">
<button class="w-full p-3 bg-primary text-white !rounded-button">Create New Deck</button>
<div class="decks space-y-2">
<div class="deck p-3 bg-gray-800 rounded cursor-pointer">
<h3>Spanish Vocabulary</h3>
<p class="text-sm text-gray-400">12 cards</p>
</div>
<div class="deck p-3 bg-gray-800 rounded cursor-pointer">
<h3>Physics Formulas</h3>
<p class="text-sm text-gray-400">8 cards</p>
</div>
</div>
</div>
<div class="editor space-y-4">
<div class="input-group space-y-2">
<input type="text" placeholder="Term" class="w-full p-2 bg-gray-800 border-none rounded">
<input type="text" placeholder="Definition" class="w-full p-2 bg-gray-800 border-none rounded">
<button class="w-full p-2 bg-primary text-white !rounded-button">Add Card</button>
</div>
<div class="preview p-4 bg-gray-800 rounded">
<h3 class="mb-2">Preview</h3>
<div class="cards space-y-2">
<div class="card p-2 bg-gray-700 rounded flex justify-between items-center">
<div>
<p class="font-bold">Hola</p>
<p class="text-sm text-gray-400">Hello</p>
</div>
<button class="edit-card-desktop bg-gray-600 hover:bg-gray-500 p-1 rounded">
<i class="ri-edit-line ri-lg"></i>
</button>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="watch-view h-screen flex flex-col">
<div class="flex items-center justify-end p-2">
  <div class="sync-status-watch text-xs text-primary flex items-center">
    <span>Connected</span>
    <i class="ri-wifi-line ml-1 sync-indicator"></i>
  </div>
</div>
<div class="flex-1 relative">
<div class="absolute inset-0 flex items-center">
<button class="prev-card w-1/3 h-full flex items-center justify-center opacity-60 hover:opacity-100 transition-opacity">
<i class="ri-arrow-left-s-line text-2xl"></i>
</button>
<div class="flashcard w-1/3 h-full relative cursor-pointer">
<div class="flashcard-front absolute inset-0 flex items-center justify-center bg-gray-800 rounded p-2">
<p class="text-center text-base">Hola</p>
</div>
<div class="flashcard-back absolute inset-0 flex items-center justify-center bg-gray-800 rounded p-2">
<p class="text-center text-sm">Hello</p>
</div>
</div>
<button class="next-card w-1/3 h-full flex items-center justify-center opacity-60 hover:opacity-100 transition-opacity">
<i class="ri-arrow-right-s-line text-2xl"></i>
</button>
</div>
</div>
<div class="progress-dots flex justify-center gap-1 pb-2">
<div class="w-1 h-1 rounded-full bg-primary"></div>
<div class="w-1 h-1 rounded-full bg-gray-600"></div>
<div class="w-1 h-1 rounded-full bg-gray-600"></div>
</div>
<button id="edit-card-btn" class="absolute bottom-4 right-4 bg-primary text-white p-2 rounded-full shadow-lg">
<i class="ri-edit-line ri-lg"></i>
</button>
<div id="edit-modal" class="hidden fixed inset-0 bg-black bg-opacity-80 z-10 flex items-center justify-center">
<div class="bg-gray-800 p-4 rounded w-[300px]">
<h3 class="text-lg font-bold mb-4">Edit Card</h3>
<div class="space-y-3">
<div>
<label class="block text-sm mb-1">Term</label>
<input id="edit-term" type="text" class="w-full p-2 bg-gray-700 border-none rounded text-white" value="">
</div>
<div>
<label class="block text-sm mb-1">Definition</label>
<input id="edit-definition" type="text" class="w-full p-2 bg-gray-700 border-none rounded text-white" value="">
</div>
<div class="flex gap-2 mt-4">
<button id="cancel-edit" class="flex-1 py-2 bg-gray-600 text-white !rounded-button">Cancel</button>
<button id="save-edit" class="flex-1 py-2 bg-primary text-white !rounded-button">Save</button>
</div>
<div class="text-xs text-center mt-2 text-gray-400">Changes will sync across all devices</div>
</div>
</div>
</div>
</div>
<script>
const mockData = {
decks: [
{
name: "Spanish Vocabulary",
cards: [
{ id: "card1", term: "Hola", definition: "Hello" },
{ id: "card2", term: "Gracias", definition: "Thank you" },
{ id: "card3", term: "Por favor", definition: "Please" }
]
}
]
};
let currentDeckIndex = 0;
let currentCardIndex = 0;
const flashcard = document.querySelector('.flashcard');
const prevBtn = document.querySelector('.prev-card');
const nextBtn = document.querySelector('.next-card');
const editBtn = document.getElementById('edit-card-btn');
const editModal = document.getElementById('edit-modal');
const editTerm = document.getElementById('edit-term');
const editDefinition = document.getElementById('edit-definition');
const cancelEditBtn = document.getElementById('cancel-edit');
const saveEditBtn = document.getElementById('save-edit');
const syncStatusElement = document.querySelector('.sync-status');
// Setup WebSocket connection
const socket = new WebSocket('wss://echo.websocket.org'); // In a real app, use your actual WebSocket server
let isConnected = false;
socket.onopen = () => {
  isConnected = true;
  updateSyncStatus('Connected');
  console.log('WebSocket connection established');
};
socket.onclose = () => {
  isConnected = false;
  updateSyncStatus('Disconnected');
  console.log('WebSocket connection closed');
  
  // Try to reconnect after 5 seconds
  setTimeout(() => {
    if (!isConnected) {
      updateSyncStatus('Reconnecting...');
      // In a real implementation, you would recreate the socket here
    }
  }, 5000);
};
socket.onerror = (error) => {
  console.error('WebSocket error:', error);
  updateSyncStatus('Connection error');
};
socket.onmessage = (event) => {
  try {
    const data = JSON.parse(event.data);
    
    if (data.type === 'card_update') {
      // Find and update the card
      const deck = mockData.decks[data.deckIndex];
      if (deck) {
        const cardIndex = deck.cards.findIndex(card => card.id === data.card.id);
        if (cardIndex !== -1) {
          deck.cards[cardIndex] = data.card;
          
          // If we're currently viewing this card, update the display
          if (currentDeckIndex === data.deckIndex && currentCardIndex === cardIndex) {
            updateCard();
          }
          
          // Update desktop view if needed
          updateDesktopCardPreview(data.card);
          
          // Show sync notification
          showSyncNotification('Card updated from another device');
        }
      }
    }
    
    updateSyncStatus('Last synced: Just now');
  } catch (error) {
    console.error('Error processing message:', error);
  }
};
function sendCardUpdate(card) {
  if (isConnected) {
    const updateData = {
      type: 'card_update',
      deckIndex: currentDeckIndex,
      card: card
    };
    
    socket.send(JSON.stringify(updateData));
    updateSyncStatus('Last synced: Just now');
  } else {
    updateSyncStatus('Not connected - changes not synced');
    showSyncNotification('Not connected - changes saved locally only', 'warning');
  }
}
function updateSyncStatus(message) {
  if (syncStatusElement) {
    syncStatusElement.textContent = message;
  }
}
function showSyncNotification(message, type = 'success') {
  const notification = document.createElement('div');
  notification.className = `fixed bottom-16 left-1/2 transform -translate-x-1/2 py-2 px-4 rounded-full text-sm z-20 ${type === 'warning' ? 'bg-yellow-500' : 'bg-primary'} text-white`;
  notification.textContent = message;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.remove();
  }, 3000);
}
function updateDesktopCardPreview(updatedCard) {
  const desktopCards = document.querySelector('.desktop-view .cards');
  if (desktopCards) {
    const cardElements = desktopCards.querySelectorAll('.card');
    cardElements.forEach(cardElement => {
      const termElement = cardElement.querySelector('p.font-bold');
      const definitionElement = cardElement.querySelector('p.text-sm');
      
      if (termElement && termElement.textContent === updatedCard.term) {
        termElement.textContent = updatedCard.term;
        definitionElement.textContent = updatedCard.definition;
      }
    });
  }
}
flashcard.addEventListener('click', () => {
  flashcard.classList.toggle('flipped');
});
prevBtn.addEventListener('click', () => {
  if (currentCardIndex > 0) {
    currentCardIndex--;
    updateCard();
  }
});
nextBtn.addEventListener('click', () => {
  if (currentCardIndex < mockData.decks[currentDeckIndex].cards.length - 1) {
    currentCardIndex++;
    updateCard();
  }
});
editBtn.addEventListener('click', () => {
  const card = mockData.decks[currentDeckIndex].cards[currentCardIndex];
  editTerm.value = card.term;
  editDefinition.value = card.definition;
  editModal.classList.remove('hidden');
});
cancelEditBtn.addEventListener('click', () => {
  editModal.classList.add('hidden');
});
saveEditBtn.addEventListener('click', () => {
  const card = mockData.decks[currentDeckIndex].cards[currentCardIndex];
  card.term = editTerm.value;
  card.definition = editDefinition.value;
  
  // Update local UI
  updateCard();
  editModal.classList.add('hidden');
  
  // Send update to other devices
  sendCardUpdate(card);
  
  // Show save confirmation
  showSyncNotification('Card updated successfully');
});
function updateCard() {
  const card = mockData.decks[currentDeckIndex].cards[currentCardIndex];
  document.querySelector('.flashcard-front p').textContent = card.term;
  document.querySelector('.flashcard-back p').textContent = card.definition;
  flashcard.classList.remove('flipped');
  updateProgressDots();
}
function updateProgressDots() {
  const totalCards = mockData.decks[currentDeckIndex].cards.length;
  const dotsContainer = document.querySelector('.progress-dots');
  dotsContainer.innerHTML = '';
  for (let i = 0; i < totalCards; i++) {
    const dot = document.createElement('div');
    dot.className = `w-1 h-1 rounded-full ${i === currentCardIndex ? 'bg-primary' : 'bg-gray-600'}`;
    dotsContainer.appendChild(dot);
  }
}
// Initialize
updateCard();
// Simulate receiving updates from other devices (for demo purposes)
setTimeout(() => {
  const simulatedUpdate = {
    type: 'card_update',
    deckIndex: 0,
    card: { 
      id: "card1", 
      term: "Hola", 
      definition: "Hello (updated from another device)" 
    }
  };
  
  const event = { 
    data: JSON.stringify(simulatedUpdate) 
  };
  
  socket.onmessage(event);
}, 10000);
</script>
</body>
</html>
